
CodeStudio - https://www.codingninjas.com/codestudio/problems/total-unique-paths_1081470?leftPanelTab=0

1) Recursion :
TLE 

int rec(int m, int n)
{
    if(m==0 && n==0)
    {
        return 1;
    }
    if(m<0 || n<0)
    {
        return 0;
    }
    int up=rec(m-1,n);   
    int left=rec(m,n-1);
    return up+left;
}

int uniquePaths(int m, int n) {	
    return rec(m-1,n-1);
}

T.C. - O(2^m*n) 
S.C. - O(Path length)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2) Memoization :

int rec(int m, int n, vector<vector<int>>& dp)
{
    if(m==0 && n==0)
    {
        return 1;
    }
    if(m<0 || n<0)
    {
        return 0;
    }
    if(dp[m][n]!=-1)
    {
        return dp[m][n];
    }
    int up=rec(m-1,n,dp);   
    int left=rec(m,n-1,dp);
    return dp[m][n] = up+left;
}

int uniquePaths(int m, int n) {	
    vector<vector<int>> dp(m,vector<int>(n,-1));
    return rec(m-1,n-1,dp);
}

T.C. - O(n*m)
S.C. - O((n-1)+(m-1)) + O(n*m)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

3) Tabulation :

int uniquePaths(int m, int n) {
    int dp[m][n];
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==0 && j==0)
            {
                dp[i][j]=1;
            }
            else
            {
                int up=0;
                int left=0;
                if(i>0)
                { 
                    up=dp[i-1][j];
                }
                if(j>0)
                { 
                    left=dp[i][j-1];
                }
                dp[i][j] = left + up;
            }
        }
    }
   return dp[m-1][n-1]; 
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

4) Space Optimization :

int uniquePaths(int m, int n) {
    vector<int> prev(n);
    for(int i=0;i<m;i++)
    {
        vector<int> curr(n);
        for(int j=0;j<n;j++)
        {
            if(i==0 && j==0)
            {
                curr[j]=1;
            }
            else
            {
                int up=0;
                int left=0;
                if(i>0)
                { 
                    up=prev[j];
                }
                if(j>0)
                { 
                    left=curr[j-1];
                }
                curr[j] = left + up;
            }
        }
       prev=curr; 
    }
   return prev[n-1]; 
}
